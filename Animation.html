<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jogo Megaman - Animação por Sprites</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #f0f8ff;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .game-container {
            position: relative;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #0066cc;
            background-color: #f0f0f0;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }
        .controls {
            background-color: #e6f2ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 800px;
        }
        .controls h3 {
            margin-top: 0;
            color: #0066cc;
        }
        .key {
            display: inline-block;
            background-color: #ddd;
            padding: 5px 10px;
            border-radius: 4px;
            margin: 0 5px;
            box-shadow: 0 2px 2px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <h1>Megaman Runner - Animação Melhorada</h1>
    <div class="game-container">
        <canvas id="gameCanvas" width="800" height="265"></canvas>
    </div>
    
    <div class="controls">
        <h3>Controles</h3>
        <p><span class="key">←</span> <span class="key">→</span> Mover | <span class="key">J</span> Pular | <span class="key">S</span> Atirar</p>
    </div>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Definição dos estados do jogo
        const VM_STANDBY = 0;
        const VM_WALK = 1;
        const VM_SHOOT = 2;
        const VM_JUMP = 3;

        // Inicializações
        let facingDirection = 'right';
        let action = VM_STANDBY;
        let actionTime = 0;
        let screenPosition = 0;
        let keyState = {};
        let isJumping = false;
        let gravity = 0.5;
        let jumpVelocity = -10;
        let currentJumpVelocity = 0;
        let groundLevel = canvas.height - 80;
        let personY = groundLevel;
        let personHeight = 80;
        let lastFrameTime = performance.now();
        let deltaTime = 0;
        let frameIndex = 0;
        let frameTime = 0;
        const frameDuration = 100; // Duração de cada frame em ms

        // Sistema de projéteis
        const projectiles = [];

        class Projectile {
            constructor(x, y, direction) {
                this.x = x;
                this.y = y;
                this.direction = direction;
                this.speed = 8;
                this.width = 15;
                this.height = 8;
                this.active = true;
            }

            update(dt) {
                if (this.direction === 'right') {
                    this.x += this.speed * (dt / 16);
                } else {
                    this.x -= this.speed * (dt / 16);
                }
                if (this.x < 0 || this.x > canvas.width) {
                    this.active = false;
                }
            }

            draw() {
                ctx.fillStyle = '#0099ff';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.width, this.height, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#99ccff';
                ctx.beginPath();
                ctx.ellipse(this.x, this.y, this.width * 0.5, this.height * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Objeto para imagens
        const images = {
            floor: new Image(),
            ceiling: new Image(),
            pillar: new Image(),
            forest: new Image(),
            personSpriteSheet: new Image()
        };

        // Configuração da spritesheet
        const larguraDoFrame = 157;
        const alturaDoFrame = 467 / 4;
        const spriteFrames = {
            standby: [0, 1, 2, 3],
            walk: [4, 5, 6, 7],
            shoot: [8, 9, 10, 11],
            jump: [12, 13, 14, 15]
        };

        function getPersonSprite(frameIndex) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = larguraDoFrame;
            canvas.height = alturaDoFrame;

            const numColunas = 4;
            const linha = Math.floor(frameIndex / numColunas);
            const coluna = frameIndex % numColunas;
            const spriteX = coluna * larguraDoFrame;
            const spriteY = linha * alturaDoFrame;

            ctx.drawImage(
                images.personSpriteSheet,
                spriteX,
                spriteY,
                larguraDoFrame,
                alturaDoFrame,
                0,
                0,
                larguraDoFrame,
                alturaDoFrame
            );

            return canvas;
        }

        // Carregando as imagens
        images.personSpriteSheet.src = 'images/all.png';
        images.floor.src = 'images/chao.png';
        images.ceiling.src = 'images/teto.png';
        images.pillar.src = 'images/pilar.png';
        images.forest.src = 'images/floresta.png';

        // Controles
        window.addEventListener('keydown', (e) => {
            keyState[e.key] = true;
        });

        window.addEventListener('keyup', (e) => {
            keyState[e.key] = false;
        });

        function drawBackground() {
            const lFator = 32;
            ctx.drawImage(images.forest, 0 - screenPosition * 0.5, 0, canvas.width + 40, canvas.height);
            for (let i = 0; i < 32; i++) {
                ctx.drawImage(images.ceiling, (lFator * i) - screenPosition, -2, 32, 32);
                ctx.drawImage(images.floor, (lFator * i) - screenPosition, 232, 32, 32);
            }
            const pilarFator = 125;
            for (let i = 0; i < 10; i++) {
                ctx.drawImage(images.pillar, (pilarFator * i) - screenPosition, 34, 21, 65);
                ctx.drawImage(images.pillar, (pilarFator * i) - screenPosition, 99, 21, 65);
                ctx.drawImage(images.pillar, (pilarFator * i) - screenPosition, 164, 21, 65);
            }
        }

        function drawPerson() {
            const personX = canvas.width / 2 - 39;
            let frames;
            switch (action) {
                case VM_STANDBY:
                    frames = spriteFrames.standby;
                    break;
                case VM_WALK:
                    frames = spriteFrames.walk;
                    break;
                case VM_SHOOT:
                    frames = spriteFrames.shoot;
                    break;
                case VM_JUMP:
                    frames = spriteFrames.jump;
                    break;
            }
            const currentFrame = frames[Math.floor(frameIndex) % frames.length];
            const sprite = getPersonSprite(currentFrame);
            if (facingDirection === 'left') {
                ctx.scale(-1, 1);
                ctx.drawImage(sprite, -personX - 78, personY, 78, 80);
                ctx.scale(-1, 1);
            } else {
                ctx.drawImage(sprite, personX, personY, 78, 80);
            }
        }

        function drawStatusLabel() {
            ctx.fillStyle = '#000000';
            ctx.fillText("Ação: " + (action === VM_STANDBY ? "Parado" :
                action === VM_WALK ? "Andando" :
                action === VM_SHOOT ? "Atirando" :
                "Pulando"), 10, 64);
            ctx.fillText("Tempo da ação: " + Math.round(actionTime), 10, 80);
            ctx.fillText("Posição da tela: " + Math.round(screenPosition), 10, 96);
            ctx.fillText("s = atirar; j = pular; setas = movimentar", 10, 112);
        }

        function drawAllSprites() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
            projectiles.forEach(projectile => {
                if (projectile.active) {
                    projectile.draw();
                }
            });
            drawPerson();
            drawStatusLabel();
        }

        function createProjectile() {
            const personX = canvas.width / 2;
            const personWidth = 78;
            const projectileY = personY + personHeight / 2;
            let projectileX = facingDirection === 'right' ? personX + personWidth / 2 : personX - personWidth / 2;
            projectiles.push(new Projectile(projectileX, projectileY, facingDirection));
        }

        function updateProjectiles(dt) {
            projectiles.forEach(projectile => {
                if (projectile.active) {
                    projectile.update(dt);
                }
            });
            for (let i = projectiles.length - 1; i >= 0; i--) {
                if (!projectiles[i].active) {
                    projectiles.splice(i, 1);
                }
            }
        }

        function applyGravity(dt) {
            if (isJumping) {
                personY += currentJumpVelocity * (dt / 16);
                currentJumpVelocity += gravity * (dt / 16);
                if (personY >= groundLevel) {
                    personY = groundLevel;
                    isJumping = false;
                    currentJumpVelocity = 0;
                    if (action === VM_JUMP) {
                        action = VM_STANDBY;
                    }
                }
            }
        }

        function update(timestamp) {
            deltaTime = timestamp - lastFrameTime;
            lastFrameTime = timestamp;
            if (deltaTime > 100) deltaTime = 100;

            // Atualizar animação
            frameTime += deltaTime;
            if (frameTime >= frameDuration) {
                frameIndex = (frameIndex + 1) % 4;
                frameTime = 0;
            }

            applyGravity(deltaTime);
            updateProjectiles(deltaTime);

            switch (action) {
                case VM_STANDBY:
                    actionTime = 0;
                    if (keyState['ArrowLeft']) {
                        action = VM_WALK;
                        facingDirection = 'left';
                    } else if (keyState['ArrowRight']) {
                        action = VM_WALK;
                        facingDirection = 'right';
                    } else if (keyState['s']) {
                        action = VM_SHOOT;
                        createProjectile();
                    } else if (keyState['j'] && !isJumping) {
                        action = VM_JUMP;
                        isJumping = true;
                        currentJumpVelocity = jumpVelocity;
                    }
                    break;
                case VM_WALK:
                    actionTime += deltaTime;
                    if (keyState['ArrowRight']) {
                        screenPosition += 4 * (deltaTime / 16);
                        facingDirection = 'right';
                    } else if (keyState['ArrowLeft']) {
                        screenPosition -= 4 * (deltaTime / 16);
                        facingDirection = 'left';
                    } else {
                        action = VM_STANDBY;
                    }
                    if (keyState['s']) {
                        action = VM_SHOOT;
                        createProjectile();
                    } else if (keyState['j'] && !isJumping) {
                        action = VM_JUMP;
                        isJumping = true;
                        currentJumpVelocity = jumpVelocity;
                    }
                    break;
                case VM_SHOOT:
                    actionTime += deltaTime;
                    if (actionTime >= 300) {
                        action = VM_STANDBY;
                    }
                    break;
                case VM_JUMP:
                    actionTime += deltaTime;
                    if (keyState['ArrowRight']) {
                        screenPosition += 4 * (deltaTime / 16);
                        facingDirection = 'right';
                    } else if (keyState['ArrowLeft']) {
                        screenPosition -= 4 * (deltaTime / 16);
                        facingDirection = 'left';
                    }
                    if (keyState['s'] && actionTime % 300 < 16) {
                        createProjectile();
                    }
                    break;
            }

            drawAllSprites();
            requestAnimationFrame(update);
        }

        function init() {
            ctx.font = "16px Arial";
            images.personSpriteSheet.onload = () => {
                update(performance.now());
            };
        }
        init();
    </script>
</body>
</html>