<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Animation</title>
    <style>
        canvas {
            border: 1px solid black;
            background-color: #f0f0f0;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="265"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        /* Inicializações*/
        /* Objeto para imagens*/
        const images = {
            floor: new Image(),
            ceiling: new Image(),
            pillar: new Image(),
            forest: new Image() /* Adiciona a imagem da floresta*/
        };

        /* Carregando imagens*/
        images.floor.src = 'images/chao.png';
        images.ceiling.src = 'images/teto.png';
        images.pillar.src = 'images/pilar.png';
        images.forest.src = 'images/floresta.png'; /* Carregando a imagem da floresta*/

        function drawBackground() {
            const lFator = 32;

            /* Desenhar floresta (ao fundo)*/
            ctx.drawImage(images.forest, 0 - screenPosition * 0.5, 0, canvas.width+40, canvas.height); /* Floresta se move mais devagar*/

            /* Teto e chão*/
            for (let i = 0; i < 32; i++) {
                ctx.drawImage(images.ceiling, (lFator * i) - screenPosition, -2, 32, 32);
                ctx.drawImage(images.ceiling, (lFator * i + lFator) - screenPosition, -2, 32, 32);
                ctx.drawImage(images.floor, (lFator * i) - screenPosition, 232, 32, 32);
            }

            /* Desenhar pilares*/
            const pilarFator = 125;
            for (let i = 0; i < 10; i++) {
                ctx.drawImage(images.pillar, (pilarFator * i) - screenPosition, 34, 21, 65);
                ctx.drawImage(images.pillar, (pilarFator * i) - screenPosition, 99, 21, 65);
                ctx.drawImage(images.pillar, (pilarFator * i) - screenPosition, 164, 21, 65);
            }
        }
        function drawsallprites() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawBackground();
        }
        function update() {
            const timeElapsed = 16;
            drawsallprites();
            requestAnimationFrame(update); /* Uso do requestAnimationFrame: Desempenho: requestAnimationFrame é 
            uma abordagem eficiente para atualizar o jogo, pois permite que o navegador otimize as animações e 
            reduza a carga da CPU/GPU, sincronizando os frames com a taxa de atualização do monitor.*/
        }
        function init() {
            ctx.font = "16px Arial";
            screenPosition = 128; /* Inicializa a posição da tela */
            update(); /* usa screenPosition += (0.1 + (timeElapsed / 3));. Essa lógica aplica um fator que 
            aumenta o movimento em direção à direita e diminui para a esquerda. Isso adiciona uma leve 
            variação no tempo de transição, tornando a jogabilidade mais interessante, permitindo movimentos suaves e variáveis. */
        }
        init();
    </script>
</body>
</html>